---
title: "Stats"
author: "Панюшев Николай"
date: '14 ноября 2017 г '
output: html_document
---

#Все графики и статистический анализ здесь

```{r libraries import, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
setwd("~/R_stuff/ENCODE_NF-kB_peaks/")
source("~/R_stuff/Functions.R")
library(ggplot2)
library(tidyr)
library(dplyr)
library(data.table)
library(compiler)
```

```{r, warning=FALSE, message=FALSE, results='hide'} 
setwd("Script_files/")
unzip(zipfile = "all_bins.zip")
all_bins <- fread("all_bins.tsv")
file.remove("all_bins.tsv")
```

##Оценка вероятности получить общие бины случайно

Концепция такая - надо нагенерить случайные данные, чтобы они выглядели примерно как то, что мы видим в реальных данных. 
Для этого сгенерируем 14 (по количеству использованных клеточных линий) векторов с бинами.  

Поэтому порежем геном на кусочки, в каждом из которых есть примерно столько бинов, сколько и в реальных данных. 

Мы работаем с геномом человека он - 3млрд оснований, порежем его на кусочки примерно по 10 кб - и в каждом из этих кусочков сгенерим столько бинов, сколько в том диапазоне, который есть в реальных данных. 


В качестве иллюстрации посмотрим на распределение по 1й хромосоме бинов во всех клеточных линиях
```{r}
ggplot(all_bins[Chromosome=="chr1", ,], aes(Peak_Bins))+
         geom_histogram()+
  facet_wrap(~ Cell_line)+       
  theme_bw()
```

По графику видно, что количество пиков очень сильно варьирует, но профиль повторяется, пиков нет в центромерном участке, например. 

Для начала заведем вектор, в котором сохраним среднее количество бинов в реальных данных.
`r min(all_bins$Peak_Bins)` - координата начала самого первого пика на первой хромосоме
`r max(all_bins$Peak_Bins)` - координата конца самого последнего пика на Y-хромосоме

Вне этих пределов не имеет смысла генерировать бины, потому что их нет в реальных данных совсем.

```{r}
piece_size = 10000
bins_regions <- seq(min(all_bins$Peak_Bins), max(all_bins$Peak_Bins), by = piece_size) #Определили координаты начала участков, где будем пики генерить
```

Cделаем data.table - где будет начало региона, минимальное, среднее и максимальное по всем линиям количество бинов, которые в этом регионе встречаются

```{r}
setwd("Script_files/")
if (!file.exists("regions_bins.tsv")){
  Cell_line_matrix <- matrix(data = unique(all_bins$Cell_line), ncol = length(unique(all_bins$Cell_line)),
                        nrow = length(bins_regions), dimnames = list(bins_regions, unique(all_bins$Cell_line)))
  Regions_matrix <- matrix(bins_regions, ncol = length(unique(all_bins$Cell_line)),
                        nrow = length(bins_regions))
  new_array <- array (c(Cell_line_matrix, Regions_matrix), dim = c(length(unique(all_bins$Cell_line)),
                        length(bins_regions), 2))
  sel_bins <- all_bins[, .(Cell_line, Peak_Bins)]
  
  bin_num <- function(vector){
   cell_line <- vector[1]
   region <- as.numeric(vector[2])
   bins <- sel_bins[Cell_line == cell_line, Peak_Bins]
   bins <- bins[bins > region & bins < region + piece_size]
  return(length(bins))
  }
  
  bin_number_dt <- apply(new_array, c(2,1), bin_num)
  bin_number_dt <- as.data.table(bin_number_dt)
  names(bin_number_dt) <- unique(all_bins$Cell_line) 
  fwrite(bin_number_dt, "regions_bins.tsv", sep = "\t")
}else{
  bin_number_dt <- fread("regions_bins.tsv", sep = "\t")
}

to_generate_dt <- data.table(Regions = bins_regions)
to_generate_dt$min <- sapply(bin_number_dt, min)
to_generate_dt$mean <- round(sapply(bin_number_dt, mean), digits = 0)
to_generate_dt$max <- sapply(bin_number_dt, max)
to_generate_dt <- to_generate_dt[mean != 0]   #Выбросим пустые регионы, где в среднем нет бинов, только выбросы какие-то

#Сделаем функцию, которая нам нагенерит вектора
generate_vector <- function(df, piece_size, bin_size = 50){
  df$data <- mapply(runif, runif(1, df$min, df$max), min = df$Regions, max = (df$Regions + piece_size),
                              SIMPLIFY = F)
  out_vector <- unlist(lapply(df$data, round))
  out_vector <-  out_vector%/%bin_size*bin_size
  out_vector <- sort(out_vector)
  out_vector[length(vector): piece_size/bin_size*length(df$Regions)] <- NA
  return(out_vector)
}

length(to_generate_dt$Regions)
length(generate_vector(to_generate_dt, piece_size))
tail(generate_vector(to_generate_dt, piece_size), 5)
#Теперь сделаем матричку, внутри которой будем пересекать бины
#количество рядов матрички - length(Regions), количество столбцов - 25, этого будет достаточно для генерации 1000 уникальных сочетаний по 14 линиям

intersect_matrix <- matrix(NA, nrow=length(to_generate_dt$Regions), ncol = 25)
intersect_matrix <- apply(intersect_matrix, 2, function(x) generate_vector(to_generate_dt, piece_size))
intersect_matrix <- as.data.table(intersect_matrix)

#Наконец-то попробуем пересечь бины матрички так и получить вектор с количеством общих бинов
#Сделаем функцию для этого
inter_length <- function(name_vector, df=intersect_matrix){
  my_vec1 <- Reduce(intersect, as.list(df[, .(name_vector)]))
  return(length(!is.na(my_vec1)))
}

Reduce(intersect, as.list(intersect_matrix[, .(V1, V2)]))
inter_length(c("V1", "V2"))

n_lines <- length(unique(all_bins$Cell_line))
 sample(names(intersect_matrix), n_lines)

intersect_vec <- replicate(1000, inter_length(sample(names(intersect_matrix), n_lines))) 

```


##Обобщенная статистика по общим регионам

Сделаем бокс-плот, который покажет, как распределены общие пики по fold_change и по q-value в этих клеточных линиях

Fold change distribution
```{r, echo=F}
#fold_change для начала
ggplot(common_peaks, aes(Cell_line, Fold_change))+
  geom_boxplot()+
  labs(title = "Fold_change distribution of common peaks",
       x = "Cell line",
       y = "Fold change")+
  theme_bw()
```

q-value distribution
```{r, echo=F}
#Теперь q-value
ggplot(common_peaks, aes(Cell_line, common_peaks$`q-value`))+
  geom_boxplot()+
  labs(title = "Fold_change distribution of common peaks",
       x = "Cell line",
       y = "q-value")+
  theme_bw()
```
Картинки примерно повторяют друг друга, видим, что самые качественные пики находятся в AC16, GM18505, HUVEC, IMR90

Глянем, как они распределены общие бины по хромосомам

```{r genome location, echo=F}
#Упорядочим нормально хромосомки, чтобы было красиво
common_bins$Chromosome <- factor(common_bins$Chromosome, 
                                   levels =c("chr1","chr2","chr3","chr4","chr5",
                                             "chr6","chr7","chr8","chr9","chr10",
                                             "chr11", "chr12", "chr13", "chr14", "chr15",
                                             "chr16", "chr17", "chr18", "chr19", "chr20",
                                             "chr21", "chr22", "chrX", "chrY"))

ggplot(common_bins, aes(Chromosome, fill = Chromosome))+
  geom_histogram(aes(fill=Chromosome), alpha = 0.5, stat = "count") +
  labs(title = "Common bin location distribution",
       x = "Genome location",
       y = "Peak number")+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_rect(fill = "white", 
            colour = NA), panel.border = element_rect(fill = NA, 
            colour = "grey20"), panel.grid.major = element_line(colour = "grey92"), 
            panel.grid.minor = element_line(colour = "grey92", 
                size = 0.25), strip.background = element_rect(fill = "grey85", 
                colour = "grey20"), legend.key = element_rect(fill = "white", 
                colour = NA), complete = TRUE)
```

Выглядит прикольно, видим, что у нас больше всего общих бинов на 1 и на 18 хромосоме.

Интересно, что же там такое?

## График по сочетаниям

Теперь построим график по количеству бинов во всех возможных пересечениях
```{r}
if (!file.exists("combinations.tsv")){
  bins_intersect(all_bins)
}
comb_df <- fread("combinations.tsv", "\t")
```

```{r, echo=F}
#Построим графичек
ggplot(comb_df, aes(x = Line_number, y = Bin_numbers))+
  geom_jitter(alpha = 0.5, color = "red", size = 1.5, na.rm = T)+
  #geom_smooth(method = "nls", formula = Bin_numbers ~ a+Line_number/b*Line_number,  se = FALSE, fullrange = TRUE)+
  labs(title = "Common bin number",
       x = "Number of lines",
       y = "Common peak number")+
  ylim(0, 2e+05)+
theme_bw()
```

```{r}
comb_df[, round(mean(Bin_numbers), digits = 0), by = Line_number] 
```
Всего вышло `r min(comb_df$Bin_numbers)` общих бинов

```{r clean-up, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
rm(list = setdiff(ls(), lsf.str()))
```
