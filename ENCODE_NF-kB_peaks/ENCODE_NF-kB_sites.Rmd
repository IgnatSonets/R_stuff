title: "ENCODE_NF-kB"
author: "Панюшев Николай"
date: '15 мая 2017 г '
output: html_document
---

```{r libraries import, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
setwd("~/R_stuff/ENCODE_NF-kB_peaks/")
source("~/R_stuff/Functions.R")
library(ggplot2)
library(tidyr)
library(dplyr)
library(data.table)
library(compiler)
```

Импортнем all_bins
```{r, warning=FALSE, message=FALSE, results='hide'} 
unzip(zipfile = "all_bins.zip")
all_bins <- fread("all_bins.tsv")
file.remove("all_bins.tsv")
```

#В этом документе должны остаться только:
* Пересечение бинов
* Преобразование бинов в пики обратно
* Центровка пиков по саммитам
* Наращивание пиков

Все остальное - в другие файлы раскидать!!!

## Пересечения бинов

Посмотрим, есть ли пересечения бинов

```{r}
#Немного говнокода, но мы переживем, зато не надо ничего руками делать
all_intersect <- Reduce(intersect, all_bins[, .(list(unique(Peak_Bins))), Cell_line]$V1)
```
Итого,количество общих бинов `r length(all_intersect)` 

Теперь отберем только общие бины, остальные нас уже не интересуют
```{r}
common_bins <- all_bins[all_bins$Peak_Bins %in% all_intersect, ]
```


## Аннтотация общих бинов

Глянем, как они распределены общие бины по хромосомам

```{r genome location}
ggplot(common_bins, aes(Chromosome, fill = Chromosome))+
  geom_histogram(aes(fill=Chromosome), alpha = 0.5, stat = "count") +
  labs(title = "Common bin location distribution",
       x = "Genome location",
       y = "Peak number")+
   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_rect(fill = "white", 
            colour = NA), panel.border = element_rect(fill = NA, 
            colour = "grey20"), panel.grid.major = element_line(colour = "grey92"), 
            panel.grid.minor = element_line(colour = "grey92", 
                size = 0.25), strip.background = element_rect(fill = "grey85", 
                colour = "grey20"), legend.key = element_rect(fill = "white", 
                colour = NA), complete = TRUE)

```

Выглядит прикольно, видим, что у нас больше всего общих бинов на 1 и на 18 хромосоме.

Интересно, что же там такое?

Подготовим из переменной с бинами полноценный .bed файл
```{r}
#Теперь переведем бины обратно в пики
common_peaks <- aggregate(common_bins$Peak_Bins,
                          by = list(common_bins$Peak_name, common_bins$Cell_line),
                          FUN = min)

names(common_peaks) <- c("Peak_name", "Cell_line", "Start")

common_peaks$Stop <- aggregate(common_bins$Peak_Bins,
                          by = list(common_bins$Peak_name,common_bins$Cell_line),
                          FUN = function(x) max(x)+50)[,3]

common_peaks$Chromosome <- aggregate(common_bins$Chromosome,
                          by = list(common_bins$Peak_name),
                          FUN = function(x) x[1])[,2]

common_peaks$Fold_change <- aggregate(common_bins$fold_change,
                          by = list(common_bins$Peak_name),
                          FUN = function(x) x[1])[,2]

common_peaks$'p-value' <- aggregate(common_bins$`p-value`,
                          by = list(common_bins$Peak_name),
                          FUN = function(x) x[1])[,2]

common_peaks$'q-value' <- aggregate(common_bins$`q-value`,
                          by = list(common_bins$Peak_name),
                          FUN = function(x) x[1])[,2]


#Переставим в правильном порядке столбцы, чтобы bedtools съел
common_peaks <- common_peaks[,c("Chromosome", "Start", "Stop", "Peak_name", 
                             "Fold_change", "p-value", "q-value", "Cell_line")]

# Проверим, нет ли косяков в .bed файле и запишем в файл
stopifnot(sum(common_peaks$Start > common_peaks$Stop) == 0)
fwrite(common_peaks, "peaks.bed", sep = "\t", col.names = FALSE)
```

Удалим ненужную переменную
```{r}
rm(all_intersect)
```

Сделаем бокс-плот, который покажет, как распределены общие пики по fold_change и по q-value в этих клеточных линиях

```{r}
#fold_change для начала
ggplot(common_peaks, aes(Cell_line, Fold_change))+
  geom_boxplot()+
  labs(title = "Common Peak distribution",
       x = "Cell line",
       y = "Fold change")+
  theme_bw()
```
```{r}
#Теперь q-value
ggplot(common_peaks, aes(Cell_line, common_peaks$`q-value`))+
  geom_boxplot()+
  labs(title = "Common Peak distribution",
       x = "Cell line",
       y = "Fold change")+
  theme_bw()
```
Картинки примерно повторяют друг друга, видим, что самые качественные пики находятся в AC16, GM18505, HUVEC, IMR90

Проаннотируем, как в прошлый раз:
Используем ту же аннотацию, которую распарсили

```{r Получение аннотации}
annotation_v24 <- fread("/home/nickolay/R_stuff/NF-kB_sites/Annotation/Gencode_v24.bed")

#Теперь вытащим только транскрипты
transcripts <- subset(annotation_v24, annotation_v24$Type == "transcript")
transcripts$Type <- NULL
fwrite(transcripts, "transcripts.bed", sep = "\t", col.names = FALSE)
```

Не будем изобретать велосипед, а сделаем скрипт, который с помощью bedtools найдет нам ближайшие гены.

```{r, engine= 'bash'}
cd ~/R_stuff/ENCODE_NF-kB_peaks/
#Отсортируем файл с транскриптами и с пиками
sortBed -i transcripts.bed > sorted_transcripts.bed
sortBed -i peaks.bed > sorted_peaks.bed

#А теперь пошли фичи искать
closestBed -D b -k 2 -a sorted_peaks.bed -b sorted_transcripts.bed > closest_transcripts.bed
```

Окей, нашли ближайшие транскрипты, отфильруем их

```{r}
features <- fread("closest_transcripts.bed")
names(features) <- c("Chromosome", "peak_Start", "peak_Stop", "Peak_name", 
                             "Fold_change", "p-value", "q-value", "Cell_line",
                     "Chr", "transcript_Start", "transcript_Stop", "Strand", 
                     "Ensemble_ID", "distance")
features$Chr <- NULL
# Убрали пики, которые лежат очень далеко в пустоте, т.е. от них до гена более 3000 нуклеотидов

features <- subset(features, features$distance<3000 & features$distance > - 3000)

#Удалим хвостики у названий транскриптов
features$Ensemble_ID <- gsub("\\.\\d+", "", features$Ensemble_ID)
```

Теперь попробуем проаннотировать гены по GO

```{r common peaks annotation}
library(biomaRt)

# define biomart object
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

# query biomart
BM_out <- getBM(attributes = c("chromosome_name","ensembl_transcript_id", 
                               "uniprotswissprot", "hgnc_symbol",
                               "transcript_biotype", "name_1006", 
                                "namespace_1003"),
                 filters = "ensembl_transcript_id",
                values = features$Ensemble_ID, 
                mart = mart,
                uniqueRows = TRUE)
rm(mart)
```
Теперь, когда у нас есть огромная аннотация, надо ее расчистить
```{r}
#Удалим неинформативные GO
BM_out <- BM_out[BM_out$name_1006 != "molecular_function" &
                  BM_out$name_1006 != "cellular_component" &
                   BM_out$name_1006 != "biological_process" ,]

GO_data <- BM_out %>% group_by(namespace_1003, ensembl_transcript_id)
names(GO_data) <- c("Chromosome", "Ensemble_ID", "Uniprot_ID", "Gene_symbol", "Biotype",  "GO_name", "Namespace")
rm(BM_out)
```
Славно, теперь давай докинем высоту пиков в разных линиях

```{r}
#Сделаем маленький датасет со всем необходимым
features <- features[ , c("Ensemble_ID", "distance", "peak_Start", "peak_Stop","Cell_line", "Fold_change", "p-value", "q-value")]

final_peaks <- merge(GO_data, features)
fwrite(final_peaks, "final_peaks.txt")
rm(features, GO_data)
```
Так, теперь посмотрим на те гены, около которых лежат общие бины

Не будем учитывать ничего, просто посмотрим, какие есть
```{r}
final_genes <- unique(final_peaks[final_peaks$Biotype == "protein_coding","Gene_symbol"])
write.csv(final_genes, file = "final_genes.csv", quote = F, row.names = F, col.names = F)
```

Всего генов вышло - `r length(final_genes)`


Вот и славно,все вроде заджойнилось
Теперь давай-ка глянем на функции, которые у нас вылезли по GO:
```{r}
mf_table <- table(subset(final_peaks$GO_name, final_peaks$Namespace == "molecular_function"))

cc_table <- table(subset(final_peaks$GO_name, final_peaks$Namespace == "cellular_component"))

bp_table <- table(subset(final_peaks$GO_name, final_peaks$Namespace == "biological_process"))

head(sort(mf_table, decreasing = T))
head(sort(bp_table, decreasing = T))
head(sort(cc_table, decreasing = T))
rm(mf_table, cc_table, bp_table)
```

Panther reactome pathways нам говорит, что с p-value 4.78E-02 обогащен apoptosis pathway 
Это немного странно, надо разбираться.


Посмотрим, на то, как распределены гены относительно TSS
```{r}
ggplot(final_peaks, aes(distance, ..count..))+
  geom_density(aes(fill=Cell_line), alpha = 0.5) +
  labs(title = "Peak position distribution",
       x = "Position",
       y = "Peak number")+
    scale_x_continuous(breaks = seq(-3000, 3000, 500))+
  theme_bw()



ggplot(final_peaks[final_peaks$distance!=0,], aes(distance, ..count..))+
  geom_density(aes(fill=Cell_line), alpha = 0.5) +
  labs(title = "Peak position distribution",
       x = "Position",
       y = "Peak number")+
    scale_x_continuous(breaks = seq(-3000, 3000, 500))+
  theme_bw()

```
Интересный график, понимать буквально я, его, конечно не буду

##Нормальная аннотация по ближайшим TSS

Проанализируем полученные участки по ближайшим генам
Оценим расстояние до ближайшего старт-кодона, его будем определять как первый нуклеотид транскрипта
Достанем для начала из аннотации все транскрипты и запишем их в отдельный .bed 

```{r}
start_codons_v24 <- annotation_v24[annotation_v24$Type == "transcript"]
start_codons_v24$Type <- NULL
#Добавим по 10 нуклеотидов к старту, чтобы нормально съел bedtools
start_codons_v24$Stop <- start_codons_v24$Start + 10

#Проверяем на косячки
sum(start_codons_v24$Start > start_codons_v24$Stop) #Если 0, то все в порядке

#Запишем в файл
fwrite(start_codons_v24, file = "start_codons.bed", sep = "\t", col.names = FALSE)
```

bedtools closest
```{r, engine= 'bash'}
cd ~/R_stuff/ENCODE_NF-kB_peaks/
#Отсортируем файл с регуляторными фичами
sort -k 1,1 -k2,2n start_codons.bed > start_codons_sorted.bed
rm start_codons.bed && mv start_codons_sorted.bed start_codons.bed 

#А теперь найдем ближайшие TSS
closestBed -D b -k 2 -a common_bins.bed -b start_codons.bed > closest_start_codons.bed
```

Посмотрим, что же вышло
```{r}
closest_TSS <- fread("closest_start_codons.bed", sep = "\t")
names(closest_TSS) <- c("Chromosome", "peak_Start", "peak_Stop", 
                             "Chr", "feature_Start", "feature_Stop",  
                     "Strand", "Ensemble_ID", "distance")
closest_TSS$Chr <- NULL

#Удалим хвостики у названий транскриптов
closest_TSS$Ensemble_ID <- gsub("\\:\\d+", "", closest_TSS$Ensemble_ID)

#Уберем дупликаты
closest_TSS <- closest_TSS[!duplicated(closest_TSS)]

#Упорядочим нормально хромосомки, чтобы было красиво
closest_TSS$Chromosome <- factor(closest_TSS$Chromosome, 
                                   levels =c("chr1","chr2","chr3","chr4","chr5",
                                             "chr6","chr7","chr8","chr9","chr10",
                                             "chr11", "chr12", "chr13", "chr14", "chr15",
                                             "chr16", "chr17", "chr18", "chr19", "chr20",
                                             "chr21", "chr22", "chrX", "chrY"))

#Построим график, чтобы понимать распределение этих участков относительно TSS

ggplot(closest_TSS, aes(distance))+
  geom_histogram(fill = "red", alpha = 0.5)+
  labs(title = "Peak position distribution",
       x = "Position",
       y = "Peak number")+
  theme_bw()


ggplot(closest_TSS, aes(Chromosome, distance))+
  geom_boxplot()+
  labs(title = "Peak position distribution",
       x = "Position",
       y = "Peak number")+
    #scale_x_continuous(breaks = seq(-3000, 3000, 500))+
  theme_bw()

```
Что-то сайты вокруг TSS примерно распределены.

##Консенсусные сайты.
Теперь настает время расковыривать консенсусную последовательность.

Для начала попробуем посмотреть, не раскластерятся ли они на 2 группы по последовательностям?

Для этого выгрузим последовательности в common_bins.fasta
Запустим для этого bedtools

```{r bed to fasta ,engine='bash'}
bedtools getfasta -fo common_bins.fa -fi ~/Human_genome/Genprime_v24/genprime_v24.fa -bed ~/R_stuff/ENCODE_NF-kB_peaks/common_bins.bed
```

Не раскластерились, все эти последовательности довольно-таки разные.

###Отцентруем по саммитам
Так как у нас есть саммиты для каждого из пиков, то сейчас мы сделаем .bed, где все участки общие будут отцентрованы по позиции саммита.
Заодно удлинним до 1000 нуклеотидов общие участки, мало ли чего 
```{r summit_centered}
region_length <- 1000
for_fasta <- bins_for_bed
for_fasta$Start <- bins_for_bed$Summit - region_length/2
for_fasta$Stop <- bins_for_bed$Summit + region_length/2

for_fasta$Stop - for_fasta$Start  == region_length #Проверили, все ли у нас получилось
# Сделаем .bed
fwrite(for_fasta, file = "1000_centered.bed", sep = "\t", col.names = FALSE)
rm(region_length, for_fasta)
```

```{r bed to fasta, engine='bash'}
bedtools getfasta -fo 1000_centered.fa -fi ~/Human_genome/Genprime_v24/genprime_v24.fa -bed ~/R_stuff/ENCODE_NF-kB_peaks/1000_centered.bed
```



Попробуем вытащить бэкграунд для консенсусных сайтов - для этого нам надо отфильтровать мусор всякий.
То есть возьмем бины, которые встречаются в 2х клеточных линиях, если будем брать больше, то бэкграундных бинов будет слишком мало
 
```{r}
for (i in 1:5){
  t <- sample(unique(all_bins$Cell_line), size = 2)
  intersect <- intersect(all_bins[Cell_line == t[1], Peak_Bins],
                        all_bins[Cell_line == t[2], Peak_Bins])
  temp_bins <- all_bins[all_bins$Peak_Bins %in% intersect, 
                        .(Chromosome, Cell_line, Peak_name, Peak_Bins) ]
  temp_bins <- temp_bins[Cell_line == t[1], .(Chromosome, Peak_Bins), by=Peak_name]
  temp_bins <- temp_bins[ , .(Chromosome, Start = min(Peak_Bins), 
                                  Stop = max(Peak_Bins)+50), by=Peak_name]
  temp_bins <- temp_bins[!duplicated(temp_bins), ]
  temp_bins$new_start <- temp_bins$Start - (500 - (temp_bins$Stop - temp_bins$Start))/2
  temp_bins$new_stop <- temp_bins$Stop + (500 - (temp_bins$Stop - temp_bins$Start))/2
  temp_bins$Peak_name <- temp_bins$Start <- temp_bins$Stop <- NULL
  filename <- paste(c(t, "bg.bed"), collapse = "_")
  fwrite(temp_bins, filename, sep = "\t", col.names = FALSE)
  rm(filename, i, t, temp_bins, intersect)
}
```
Теперь сделаем из .bed .fasta
Этот кусок кода не работает из R, только в консоли почему-то.
```{r bed to fasta, engine='bash', eval = F}
for i in *bg.bed
do
    TAG=${i%%.bed}
    bedtools getfasta -fo $TAG.fa -fi ~/Human_genome/Genprime_v24/genprime_v24.fa -bed ~/R_stuff/ENCODE_NF-kB_peaks/$i
    rm $i
done
```



```{r clean-up, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
rm(list = setdiff(ls(), lsf.str()))
```
